package com.agamutan.demo.controller

import com.agamutan.demo.model.Task
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

/**
 * TaskController handles all HTTP requests related to Task management.
 * This is a REST API controller that provides CRUD operations for tasks.
 */
@RestController
@RequestMapping("/api/tasks")
class TaskController {

    // In-memory storage for tasks using a MutableList
    // In a real application, this would be replaced with a database
    private val tasks = mutableListOf<Task>()

    // Counter to generate unique IDs for new tasks
    private var nextId = 1L

    /**
     * GET /api/tasks
     * Retrieves all tasks from the in-memory storage
     *
     * @return List of all tasks
     */
    @GetMapping
    fun getAllTasks(): List<Task> {
        return tasks
    }

    /**
     * GET /api/tasks/{id}
     * Retrieves a specific task by its ID
     *
     * @param id The ID of the task to retrieve
     * @return ResponseEntity with the task if found, or 404 Not Found
     */
    @GetMapping("/{id}")
    fun getTaskById(@PathVariable id: Long): ResponseEntity<Task> {
        val task = tasks.find { it.id == id }
        return if (task != null) {
            ResponseEntity.ok(task)
        } else {
            ResponseEntity.notFound().build()
        }
    }

    /**
     * POST /api/tasks
     * Creates a new task and adds it to the in-memory storage
     *
     * @param taskRequest The task data from the request body (without ID)
     * @return ResponseEntity with the created task and 201 Created status
     */
    @PostMapping
    fun createTask(@RequestBody taskRequest: TaskRequest): ResponseEntity<Task> {
        val newTask = Task(
            id = nextId++,
            title = taskRequest.title,
            description = taskRequest.description,
            completed = taskRequest.completed ?: false
        )
        tasks.add(newTask)
        return ResponseEntity.status(HttpStatus.CREATED).body(newTask)
    }

    /**
     * PUT /api/tasks/{id}
     * Updates an existing task with new data
     *
     * @param id The ID of the task to update
     * @param taskRequest The updated task data from the request body
     * @return ResponseEntity with the updated task if found, or 404 Not Found
     */
    @PutMapping("/{id}")
    fun updateTask(
        @PathVariable id: Long,
        @RequestBody taskRequest: TaskRequest
    ): ResponseEntity<Task> {
        val index = tasks.indexOfFirst { it.id == id }
        return if (index != -1) {
            val updatedTask = Task(
                id = id,
                title = taskRequest.title,
                description = taskRequest.description,
                completed = taskRequest.completed ?: false
            )
            tasks[index] = updatedTask
            ResponseEntity.ok(updatedTask)
        } else {
            ResponseEntity.notFound().build()
        }
    }

    /**
     * DELETE /api/tasks/{id}
     * Deletes a task from the in-memory storage
     *
     * @param id The ID of the task to delete
     * @return ResponseEntity with 204 No Content if deleted, or 404 Not Found
     */
    @DeleteMapping("/{id}")
    fun deleteTask(@PathVariable id: Long): ResponseEntity<Void> {
        val removed = tasks.removeIf { it.id == id }
        return if (removed) {
            ResponseEntity.noContent().build()
        } else {
            ResponseEntity.notFound().build()
        }
    }

    /**
     * TaskRequest is a data class used for incoming requests (POST/PUT)
     * It doesn't include the ID since that's generated by the server
     */
    data class TaskRequest(
        val title: String,
        val description: String,
        val completed: Boolean? = false
    )
}